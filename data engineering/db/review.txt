->Remove duplicated:
    ->select distinct col_name
    ->select distinct (col_name1), col_name2
    ==>selct count(distinct name)
    ->To keep the “first” row of each group of duplicates where the expression is equal. See the following syntax:
        SELECT DISTINCT ON (column_1), column_2
        FROM tbl_name
    ====>PostgreSQL also provides the DISTINCT ON (expression) to keep the “first” row of each group of duplicates where the expression is equal.
->not equal to operator: <> or !=.
->select * from t_n order by name1 ASC, name2 desc;
    ->by default asc.
    ->we can also use where name1, name2 are not retrieved: select addr from t_n order by name1 ASC, name2 desc;
->PostgreSQL returns n number of rows generated by the query. If n is zero or NULL , it produces the result that is same as omitting the LIMIT clause.
    SELECT *
    FROM TABLE
    LIMIT n;
    ->In case you want to skip a number of rows before returning n rows, you use OFFSET clause followed by the LIMIT clause as follows:
        SELECT * FROM table
        LIMIT n OFFSET m;
->The expression value in (1,2) returns true if the value matches any value in the list.
    select * from tb_name value IN (SELECT value FROM tbl_name);
                (or)
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->You want to know the rental information of customer id 1 and 2:
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->Can combine with NOT:
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->We often use the BETWEEN operator in the WHERE clause of a SELECT, INSERT, UPDATE or DELETE statement.
    value BETWEEN low AND high == value >= low and value <= high;
    value NOT BETWEEN low AND high == value < low OR value > high
->LIKE, NOT LIKE, ILIKE(case insensitive) their are other regex for postgres SQL:
    ->'%': To match any sequence of characters.
    ->'_': To match any single char.
    SELECT first_name,last_name
    FROM customer
    WHERE first_name LIKE 'Jen%';
->The GROUP BY clause must appear right after the FROM or WHERE clause. Used with Aggregate function:
    SELECT customer_id,
    SUM (amount)
    FROM payment
    GROUP BY customer_id;
->We often use the HAVING clause in conjunction with the GROUP BY clause to filter group rows that do not
  satisfy a specified condition.
    ->HAVING clause sets the condition for group rows created by the GROUP BY clause after the GROUP BY 
    clause applies while the WHERE clause sets the condition for individual rows before GROUP BY clause 
    applies.
    ->Ex:
        SELECT column_1, aggregate_function (column_2)
        FROM tbl_name
        GROUP BY column_1
        HAVING SUM (amount) > 200;
    ->In PostgreSQL, you can use the HAVING clause without the GROUP BY clause.
        ->Here the HAVING clause will turn the query into a single group.
        ->True: single row, False: No rows
->JOINS:
    ->JOIN==INNER JOIN
    ->INNER JOIN, FULL OUTER JOIN, LEFT OUTER JOIN.
        ->Ex:(set of records that only appear in the Registration table)
            SELECT * FROM Registrations
            LEFT OUTER JOIN Logins
            ON Registrations.name = Logins.name
            WHERE Logins.id IS null
    ->SELF JOIN:
        SELECT a.column_name, b.column_name
        FROM table1 a, table1 b
        WHERE a.common_field = b.common_field;
    ->CROSS JOIN:Returs all possible matching joins from both tables.
        ->Works as inner join with where clause.
        =>MYSQL interprets join without ON word as cross JOIN.
->PostgreSQL executes the query that contains a subquery in the following sequence(query in where clause):
    ● First, executes the subquery.
    ● Second, gets the result and passes it to the outer query.
    ● Third, executes the outer query.
->Create table:
    CREATE TABLE table_name (
    column_name TYPE column_constraint,
    table_constraint table_constraint
    ) INHERITS existing_table_name;
    ->The TEMPORARY keyword with CREATE TABLE is for creating a temporary table.
    ->After that, you specify an existing table from which the new table inherits. It means the new 
    table contains all columns of the existing table and the columns defined in the CREATE TABLE 
    statement. This is a PostgreSQL’s extension to SQL.
->UNIQUE – the value of the column must be unique across the whole table. However, the column can have 
many NULL values because PostgreSQL treats each NULL value to be unique. Notice that SQL standard only 
allows one NULL value in the column that has the UNIQUE constraint.
->Primary key: UNIQUE+NOT NULL
    ->Single column(column constraint)
    ->multi column(table constraint)
->CHECK: To check a condition(only +ve values allowed) when you insert or update data.
->REFERENCES – constrains the value of the column that exists in a column in another table.
->SELECT column AS new_name from table. To rename column in result query.
->UNION: SELECT c1,c2 FROM t1 UNION SELECT c1,c2 FROM t2.(col names should be same)
->Data types:TIME, DATE, TIMEDATE, TIMEDATEZ(time, date and zone), TIMESTAMP.
->Functions: TIMEZONE, NOW, TIMEOFDAY, CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP
    ->SELECT NOW()
    ->SELECT TIMEOFDAY() -> understandable time date zone format.
->Functions: 
    ->EXTRACT()
        ->To EXTRACT YEAR, MONTH, DAY, WEEK, QUARTER from timestamp.
        -> EXTRACT(YEAR FROM date_col)
    ->AGE()
        ->Calculates no of years, months, day, hours, mins, sec, milli sec from timestamp to today.
        ->AGE(date_col)
    ->TO_CHAR()
        ->To convert data_type to text and to fomat timestamp.
        ->TO_CHAR(date_col,'mm-dd-yyyy')
->SHOW: Shows the current settings of run time params.
    ->SHOW ALL.
    ->SHOW TIMEZONE.
->select count(*) from payment where EXTRACT(dow from payment_date)=1.(dow-day of week, sunday=0).
->Operator ops:
    ->select col1+col2 from t1.
->EXISTS(): To check existence of rows in sub query.
    ->slect * from t1 where EXISTS(select * from t2 where condn)
    ->selct f_n, l_n from customer AS c where Exists(select * from payment AS p where p.customer_id=c.customer_id).(Returns customer with atleast 1 payment)
->Data types:
    https://www.postgresql.org/docs/current/datatype.html
====>Exclude, Include constraints?
->SERIAL(data type) used for primary keys.
    ->It provide value in sequence 1,2,3,....
    ->Even if the value is deleted it will not be used again.
    ->Types: smallserial(2 bytes), serial(4 bytes), bigserial(8 bytes).
    ->Use Integer when using the datatype as foreign key.Eg(user_id INTEGER REFERENCES account(user_id)):account is different table name.
->Insert into table_name(c1,c2) values (v1, v2)
    ->Insert into table_name(c1,c2) select c1,c2 from tabel_name2.
    ->insert into table_name(c1,c2) values(v1,CURRENT_TIME) 
->UPDATE:
    ->UPDATE t1 set c1=val, c2=val2 WHERE condition;
    ->To update table t1 from other table values: UPDATE t1 set c1=t2.name from t2 where t1.id=t2.id;
    ->To updated rows: UPDATE t1 set c1=v1 RETURNING c1,c2
-DELETE
    ->DELETE from t1 where id=val
    ->DELETE from t1 USING t2 where t1.id=t2.id
    ->DELETE from t1 where cond RETURNING c1,c2
->ALTER:
    ->Used for:
        ->Adding, droping or renaming column names.
        ->Changing column data types.
        ->Set default values for column.
        ->Add check constraints.
        ->Rename table.
    ->ALTER TABLE table_name ADD COLUMN new_col TYPE;
    ->ALTER TABLE table_name DROP COLUMN col;
        ->DROP command in postgresql will remove all indexes, and constraints with them.
        ->But we need to use CASCADE clause to remove clolumns used in views, triggers, or stored procedures.
        ->Avoid Error if col doesn't exist: ALTER TABLE table_name DROP COLUMN IF EXISTS col;
    ->ALTER TABLE t_n RENAME TO new_table_name;
    ->ALTER TABLE table_name ALTER COLUMN col_name SET DEFAULT value;
    ->ALTER TABLE table_name ALTER COLUMN col_name SET NOT NULL;
    ->ALTER TABLE table_name ALTER COLUMN col_name DROP DEFAULT value;
    ->ALTER TABLE table_name ALTER COLUMN col_name ADD CONSTRAINT constraint_name;
->CHECK:
    ->CREATE TABLE t_n(
        id SERIAL PRIMARY KEY,
        age SMALLINT CHECK(age > 21),
        parent_age SMALLINT CHECK(parent_age > age)
    );
->CASE: Execute only when some cond'n is met.
    ->General Case:
        ->Table test:
            |a|    |a|label|
            |1| => |1|one  |
            |2|    |2|two  |
        ->SELECT a,
        CASE
          WHEN a=1 THEN 'one'
          WHEN a=2 THEN 'two'
          ELSE 'other' as label
        END
        from test;
    ->Case expr: we will not add condition in WHEN here.
        ->SELECT a,
        CASE a
          WHEN 1 THEN 'one'
          WHEN 2 THEN 'two'
          ELSE 'other' as label
        END
        from test;
->NTILE:
    ->SELECT 
        emp_no,
        department, 
        salary,
        NTILE(4) OVER(PARTITION BY department ORDER BY salary DESC) AS dept_salary_quartile,
        NTILE(4) OVER(ORDER BY salary DESC) AS salary_quartile
        FROM employees;
->Indexing: It is used to reduce I/O time(time taken to transfer data b/w RAM and hard disk) not search time.
    ->https://www.youtube.com/watch?v=s_S_MpLoDEM
=>Transaction which follow ACID rule need to be specified separately.
=>db.movies.find({$or:[{"rating.average":{$gt:9.4}},{"rating.average":{$lt:4.0}}]})
=>db.sales.find({$expr:{$gt:['$volume','$target']}}).
    -> Gives docs where attribute value of volume>target.
=>db.sales.find({$expr:{$gt:[{$cond: if:{'$volume': {$gt:190}, then:{'$subtract':['$volume',20]}, else:'$volume'}}, '$target']}})
    ->Gives docs where attribute value of v1>target where v1=volume-20 if volume>190 else v1=volume.
-> \d table_name
    ->command that describes tabe(cloumn_names, types, default values, Collation, Nullable, Indexes...).
->A wide-column database is a type of NoSQL database in which the names and format of the columns can vary across rows, even within the same table.
    ->Each data element can be referenced by the row key, but querying for a value is optimized like querying an index in a RDBMS, rather than a slow table scan.
