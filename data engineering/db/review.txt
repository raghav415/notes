->Remove duplicated:
    ->select distinct col_name
    ->select distinct (col_name1), col_name2
    ->selct count(distinct name)
    ->To keep the “first” row of each group of duplicates where the expression is equal. See the following syntax:
        SELECT DISTINCT ON (column_1), column_2
        FROM tbl_name
    ====>PostgreSQL also provides the DISTINCT ON (expression) to keep the “first” row of each group of duplicates where the expression is equal?
->not equal to operator: <> or !=.
->select * from t_n order by name1 ASC, name2 desc;
    ->by default asc.
    ->we can also use where name1, name2 are not retrieved: select addr from t_n order by name1 ASC, name2 desc;
->PostgreSQL returns n number of rows generated by the query. If n is zero or NULL , it produces the result that is same as omitting the LIMIT clause.
    SELECT *
    FROM TABLE
    LIMIT n;
    ->In case you want to skip a number of rows before returning n rows, you use OFFSET clause followed by the LIMIT clause as follows:
        SELECT * FROM table
        LIMIT n OFFSET m;
->The expression value in (1,2) returns true if the value matches any value in the list.
    select * from tb_name value IN (SELECT value FROM tbl_name);
                (or)
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->You want to know the rental information of customer id 1 and 2:
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->Can combine with NOT:
    SELECT customer_id, rental_id, return_date
    FROM rental
    WHERE customer_id IN (1, 2)
    ORDER BY return_date DESC;
->We often use the BETWEEN operator in the WHERE clause of a SELECT, INSERT, UPDATE or DELETE statement.
    value BETWEEN low AND high == value >= low and value <= high;
    value NOT BETWEEN low AND high == value < low OR value > high
->LIKE, NOT LIKE:
    ->'%': To match any sequence of characters.
    ->'_': To match any single char.
    SELECT first_name,last_name
    FROM customer
    WHERE first_name LIKE 'Jen%';
->The GROUP BY clause must appear right after the FROM or WHERE clause. Used with Aggregate function:
    SELECT customer_id,
    SUM (amount)
    FROM payment
    GROUP BY customer_id;
->We often use the HAVING clause in conjunction with the GROUP BY clause to filter group rows that do not
  satisfy a specified condition.
    ->HAVING clause sets the condition for group rows created by the GROUP BY clause after the GROUP BY 
    clause applies while the WHERE clause sets the condition for individual rows before GROUP BY clause 
    applies.
    ->Ex:
        SELECT column_1, aggregate_function (column_2)
        FROM tbl_name
        GROUP BY column_1
        HAVING SUM (amount) > 200;
    ->In PostgreSQL, you can use the HAVING clause without the GROUP BY clause.
        ->Here the HAVING clause will turn the query into a single group.
        ->True: single row, False: No rows
->JOINS:
    ->JOIN==INNER JOIN
    ->INNER JOIN, FULL OUTER JOIN, LEFT OUTER JOIN.
        ->Ex:(set of records that only appear in the Registration table)
            SELECT * FROM Registrations
            LEFT OUTER JOIN Logins
            ON Registrations.name = Logins.name
            WHERE Logins.id IS null
    ->SELF JOIN:
        SELECT a.column_name, b.column_name
        FROM table1 a, table1 b
        WHERE a.common_field = b.common_field;
->PostgreSQL executes the query that contains a subquery in the following sequence(query in where clause):
    ● First, executes the subquery.
    ● Second, gets the result and passes it to the outer query.
    ● Third, executes the outer query.
->Create table:
    CREATE TABLE table_name (
    column_name TYPE column_constraint,
    table_constraint table_constraint
    ) INHERITS existing_table_name;
    ->The TEMPORARY keyword with CREATE TABLE is for creating a temporary table.
    ->After that, you specify an existing table from which the new table inherits. It means the new 
    table contains all columns of the existing table and the columns defined in the CREATE TABLE 
    statement. This is a PostgreSQL’s extension to SQL.
->UNIQUE – the value of the column must be unique across the whole table. However, the column can have 
many NULL values because PostgreSQL treats each NULL value to be unique. Notice that SQL standard only 
allows one NULL value in the column that has the UNIQUE constraint.
->Primary key: UNIQUE+NOT NULL
    ->Single column(column constraint)
    ->multi column(table constraint)
->CHECK: To check a condition(only +ve values allowed) when you insert or update data.
->REFERENCES – constrains the value of the column that exists in a column in another table.
->SELECT column AS new_name from table. To rename column in result query.
->UNION: SELECT c1,c2 FROM t1 UNION SELECT c1,c2 FROM t2.(col names should be same)
->Data types:TIME, DATE, TIMEDATE, TIMEDATEZ(time, date and zone).
->Functions: TIMEZONE, NOW, TIMEOFDAY, CURRENT_TIME, CURRENT_DATE
    ->SELECT NOW()
    ->SELECT TIMEOFDAY() -> understandable time date zone format.
->Functions: 
    ->EXTRACT()
        ->To EXTRACT YEAR, MONTH, DAY, WEEK, QUARTER from timestamp.
        -> EXTRACT(YEAR FROM date_col)
    ->AGE()
        ->Calculates no of years, months, day, hours, mins, sec, milli sec from timestamp to today.
        ->AGE(date_col)
    ->TO_CHAR()
        ->To convert data_type to text and to fomat timestamp.
        ->TO_CHAR(date_col,'mm-dd-yyyy')
->SHOW: Shows the current settings of run time params.
    ->SHOW ALL.
    ->SHOW TIMEZONE.
->select count(*) from payment where EXTRACT(dow from payment_date)=1.(dow-day of week, sunday=0).
->Operator ops:
    ->select col1+col2 from t1.
->EXISTS(): To check existence of rows in sub query.
    ->slect * from t1 where EXISTS(select * from t2 where condn)
    ->selct f_n, l_n from customer AS c where Exists(select * from payment AS p where p.customer_id=c.customer_id).(Returns customer with atleast 1 payment)
->Data types:
    https://www.postgresql.org/docs/current/datatype.html
====>Exclude, Include constraints?
